# Construction Instructions

Each of the instructions described in this section pushes a single element to the top of the stack. In most cases, this is a reference to an object that the instruction allocates on the heap.

## C_SYMBOL

`C_SYMBOL` creates a new symbol object on the heap and pushes a reference to it to the stack.

Its structure is as follows:

```
C_SYMBOL:
   +---------------------------------------+
MSB|ssss ssss ssss ssss ssss ssss 0000 0001|LSB
   +---------------------------------------+
```

Here, the `s`s represent the symbol bits. Note that only 24 bits out of the 28 bits a symbol object can represent, can be specified using this instruction. The other four are set to 0. For example, the following instruction:

```
   +---------------------------------------+
MSB|1010 1010 1010 1010 1010 1010 0000 0001|LSB
   +---------------------------------------+
```

will create a symbol with the bits `1010 1010 1010 1010 1010 1010 0000`.

The following C++ code example shows how this instruction can be implemented.

```c++
bool c_literal_inst(int32_t op) {
    stack.push_back(allocate_term(op));
    return true;
}
```

## Literal Constructors (C_INT64, C_FLOAT64, C_STRING)

Literal constructors create constant terms that reference an existing entry in one of the constant heaps and push a reference to it to the stack.

Their format is as follows:

```
C_INT64:
   +---------------------------------------+
MSB|nnnn nnnn nnnn nnnn nnnn nnnn 0000 0101|LSB
   +---------------------------------------+
C_FLOAT64:
   +---------------------------------------+
MSB|nnnn nnnn nnnn nnnn nnnn nnnn 0000 1001|LSB
   +---------------------------------------+
C_STRING:
   +---------------------------------------+
MSB|nnnn nnnn nnnn nnnn nnnn nnnn 0000 1101|LSB
   +---------------------------------------+
```

In all cases, the `n`s represent a 24-bit index in the corresponding value heap.

Please note that this does not address the entire value heap. These instructions are only meant for literals which exist in the program (rather than values that are generated by the program at runtime). These literals are placed at the beginning of each value heap and are limited to 2^24 values of each type.

The function `c_literal_inst()` shown above also implements these instructions.

## C_NIL

`C_NIL` pushes -1 to the top of the stack, indicating a `nil`.

The following C++ code example shows how it can be implemented:

```c++
bool c_nil_inst(int32_t op) {
    stack.push_back(-1);
    return true;
}
```

## C_PAIR

`C_PAIR` pops two elements from the stack and constructs a pair consisting of them, pushing a reference to it to the stack.

For example, consider the following "before" stack:

```
top    | foo     |
       | bar     |
       | baz     |
       | apple   |
bottom | banana  |
```

Applying `C_PAIR` on this stack will result in the following "after" stack:

```
top    | (foo, bar) |
       | baz        |
       | apple      |
bottom | banana     |
```

Note that the order here matters. The top element in the stack (the first to be popped) is the first in the pair.

The following C++ code example shows how `C_PAIR` can be implemented.

```c++
bool c_pair_inst(int32_t op) {
    stack.push_back(cons(stack_pop(), stack_pop()));
    return true;
}
```

## C_VAR

`C_VAR` pushes a reference to a [local variable](non-restorable-data-structures.md#locals) to the stack.

The following C++ code example shows how this can be implemented:

```c++
bool c_var_inst(int32_t op) {
    stack.push_back(get_local((op >> 8) & 0xFFFFFF));
    return true;
}
```
